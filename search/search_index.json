{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"VibroMAF - Vibrotactile Multi-Method Assessment Fusion","text":""},{"location":"#vibrotactile-quality-metrics","title":"Vibrotactile Quality Metrics","text":"<p>This package provides implementations of existing vibrotactile quality metrics and machine learning approach that fuses the individual metric scores into a single final quality score.</p>"},{"location":"#installation","title":"Installation","text":"<p>Install <code>vibromaf</code> from PyPI:</p> <pre><code>pip install vibromaf\n</code></pre> <p>For development versions and alternative installations see the installation documentation.</p>"},{"location":"#usage","title":"Usage","text":"<ul> <li>Get Started</li> <li>Full Documentation</li> </ul>"},{"location":"#citation","title":"Citation","text":"<p>If you use this work, please cite our paper (PDF)</p> <pre><code>@inproceedings{noll_vibromaf,\n  author    = {Noll, Andreas and Hofbauer, Markus and Muschter, Evelyn and Li, Shu-Chen and Steinbach, Eckehard},\n  booktitle = {2022 IEEE Haptics Symposium (HAPTICS)},\n  title     = {Automated Quality Assessment for Compressed Vibrotactile Signals Using Multi-Method Assessment Fusion},\n  year      = {2022},\n  volume    = {},\n  number    = {},\n  pages     = {1-6},\n  doi       = {10.1109/HAPTICS52432.2022.9765599},\n  address   = {Santa Barabara, California, USA}\n}\n</code></pre>"},{"location":"#contribute","title":"Contribute","text":"<p>See our CONTRIBUTING.md</p>"},{"location":"CHANGELOG/","title":"Changelog","text":""},{"location":"CONTRIBUTING/","title":"Contribution Guidelines","text":""},{"location":"CONTRIBUTING/#setup","title":"Setup","text":"<pre><code># Setup the python virtual environment\npython3 -m venv venv\nsource venv/bin/activate\n\n# Install dependencies\npip3 install -r requirements-dev.txt\n\n# Install vibromaf as development (editable) package\npip3 install -e .\n</code></pre>"},{"location":"CONTRIBUTING/#development","title":"Development","text":"<p>We use pre-commit to manage our git pre-commit hooks. <code>pre-commit</code> is automatically installed from <code>requirements-dev.txt</code>. To set it up, call</p> <pre><code>git config --unset-all core.hooksPath # may fail if you don't have any hooks set, but that's ok\npre-commit install --overwrite\n</code></pre>"},{"location":"CONTRIBUTING/#hooks-usage","title":"Hooks Usage","text":"<p>With <code>pre-commit</code>, you don't use your linters/formatters directly anymore, but through <code>pre-commit</code>:</p> <pre><code>pre-commit run --file path/to/file1.cpp tools/second_file.py  # run on specific file(s)\npre-commit run --all-files  # run on all files tracked by git\npre-commit run --from-ref origin/master --to-ref HEAD  # run on all files changed on current branch, compared to master\npre-commit run &lt;hook_id&gt; --file &lt;path_to_file&gt;  # run specific hook on specific file\n</code></pre>"},{"location":"LICENSE/","title":"License","text":"<p>MIT License</p> <p>Copyright (c) 2021 Markus Hofbauer and Andreas Noll</p> <p>Permission is hereby granted, free of charge, to any person obtaining a copy of this software and associated documentation files (the \"Software\"), to deal in the Software without restriction, including without limitation the rights to use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of the Software, and to permit persons to whom the Software is furnished to do so, subject to the following conditions:</p> <p>The above copyright notice and this permission notice shall be included in all copies or substantial portions of the Software.</p> <p>THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.</p>"},{"location":"get-started/","title":"Get Started","text":"<p>Create a sample signal or read one from your database. Here, we create a constant signal of 1000 with length 1000 and add random white noise. For the distorted signal, we add again random white noise to the reference signal.</p> <pre><code>import numpy as np\n\nsample_reference_signal = np.ones(1000) * 1000 + np.random.randn(1000)\nsample_distorted_signal = sample_reference_signal + np.random.randn(1000)\n</code></pre>"},{"location":"get-started/#calculate-snr","title":"Calculate SNR","text":"<p>Calculate the SNR from the signals defined above.</p> <pre><code>from vibromaf.metrics.snr import snr\n\nsnr_score = snr(sample_distorted_signal, sample_reference_signal)\n\nprint(snr_score)  # Should be around 60dB\n</code></pre> <p>Find further details how to use this metric at SNR.</p>"},{"location":"get-started/#calculate-st-sim","title":"Calculate ST-SIM","text":"<p>Calculate the ST-SIM from the signals defined above.</p> <pre><code>from vibromaf.metrics.stsim import st_sim\n\nst_sim_score = st_sim(sample_distorted_signal, sample_reference_signal)\n\nprint(st_sim_score)  # Should be around 0.81\n</code></pre> <p>Find further details how to use this metric at ST-SIM.</p>"},{"location":"get-started/#calculate-spqi","title":"Calculate SPQI","text":"<p>Calculate the SPQI from the signals defined above.</p> <pre><code>from vibromaf.metrics.spqi import spqi\n\nspqi_score = spqi(sample_distorted_signal, sample_reference_signal)\n\nprint(spqi_score)  # Should be around 0.43\n</code></pre> <p>Find further details how to use this metric at SPQI.</p>"},{"location":"get-started/#full-example","title":"Full Example","text":"<p>Find the full example in <code>examples/white_noise.py</code>. All examples available can be found in the <code>examples</code> folder.</p>"},{"location":"installation/","title":"Installation","text":"<p>Use <code>pip</code> to install the latest stable version of <code>vibromaf</code> from PyPI:</p> <pre><code>pip install --upgrade vibromaf\n</code></pre> <p>The current development version is available on GitHub. Install the version from <code>HEAD</code> using <code>git</code> and <code>python setup.py</code>:</p> <pre><code>git clone https://github.com/hofbi/vibromaf.git\ncd vibromaf\npython setup.py install\n</code></pre>"},{"location":"metrics/snr/","title":"Signal-to-Noise Ratio (SNR)","text":""},{"location":"metrics/snr/#reference","title":"Reference","text":"<p>Signal to Noise Ratio.</p>"},{"location":"metrics/snr/#vibromaf.metrics.snr.nsnr","title":"<code>nsnr(distorted, reference, normalization_db=75)</code>","text":"<p>Calculate the normalized signal-to-noise ratio restricted to range of 0 to 1.</p> Source code in <code>vibromaf/metrics/snr.py</code> <pre><code>def nsnr(\n    distorted: np.array, reference: np.array, normalization_db: float = 75\n) -&gt; float:\n    \"\"\"Calculate the normalized signal-to-noise ratio restricted to range of 0 to 1.\"\"\"\n    return max(0.0, min(1.0, snr(distorted, reference) / normalization_db))\n</code></pre>"},{"location":"metrics/snr/#vibromaf.metrics.snr.snr","title":"<code>snr(distorted, reference)</code>","text":"<p>Calculate the signal-to-noise ratio.</p>"},{"location":"metrics/snr/#vibromaf.metrics.snr.snr--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted signal.</li> <li><code>reference: np.array</code> Reference signal.</li> </ul>"},{"location":"metrics/snr/#vibromaf.metrics.snr.snr--returns","title":"Returns","text":"<ul> <li><code>float</code> The SNR.</li> </ul> Source code in <code>vibromaf/metrics/snr.py</code> <pre><code>def snr(distorted: np.array, reference: np.array) -&gt; float:\n    \"\"\"Calculate the signal-to-noise ratio.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted signal.\n    * `reference: np.array` Reference signal.\n\n    Returns\n    -------\n    * `float` The SNR.\n    \"\"\"\n    distorted = preprocess_input_signal(distorted, reference)\n    return pow2db(signal_energy(reference) / signal_energy(distorted - reference))\n</code></pre>"},{"location":"metrics/spqi/","title":"Spectral Perceptual Quality Index (SPQI)","text":""},{"location":"metrics/spqi/#reference","title":"Reference","text":"<p>Spectral Perceptual Quality Index.</p>"},{"location":"metrics/spqi/#vibromaf.metrics.spqi.SPQI","title":"<code>SPQI</code>  <code>dataclass</code>","text":"<p>Spectral Perceptual Quality Index.</p> Source code in <code>vibromaf/metrics/spqi.py</code> <pre><code>@dataclass(frozen=True)\nclass SPQI:\n    \"\"\"Spectral Perceptual Quality Index.\"\"\"\n\n    eta: float\n    threshold: float\n    perceptual_spectrum_builder = PerceptualSpectrumBuilder()\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        distorted = preprocess_input_signal(distorted, reference)\n        if np.array_equal(distorted, reference):\n            return 1\n\n        ref_perceptual_spectrum = (\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(reference)\n        )\n        dist_perceptual_spectrum = (\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(distorted)\n        )\n\n        norm_perceptual_difference = compute_normalized_spectral_difference(\n            ref_perceptual_spectrum, dist_perceptual_spectrum\n        )\n\n        block_spqi_scores = self.__compute_block_spqi(norm_perceptual_difference)\n\n        return float(np.mean(block_spqi_scores))\n\n    def __compute_block_spqi(\n        self, normalized_perceptual_difference: np.array\n    ) -&gt; np.array:\n        return (\n            1 - np.tanh(self.eta * normalized_perceptual_difference - self.threshold)\n        ) / 2\n</code></pre>"},{"location":"metrics/spqi/#vibromaf.metrics.spqi.spqi","title":"<code>spqi(distorted, reference, eta=0.3, threshold=-2.0)</code>","text":"<p>Wrapper function to calculate the SPQI score.</p>"},{"location":"metrics/spqi/#vibromaf.metrics.spqi.spqi--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted vibrotactile signal.</li> <li><code>reference: np.array</code> Reference vibrotactile signal.</li> <li><code>eta: float</code> Slope of the mapping function between error and score.</li> <li><code>threshold: float</code> Offset of the mapping function.</li> </ul>"},{"location":"metrics/spqi/#vibromaf.metrics.spqi.spqi--returns","title":"Returns","text":"<ul> <li><code>float</code> The SPQI score.</li> </ul> Source code in <code>vibromaf/metrics/spqi.py</code> <pre><code>def spqi(\n    distorted: np.array, reference: np.array, eta: float = 0.3, threshold: float = -2.0\n) -&gt; float:\n    \"\"\"Wrapper function to calculate the SPQI score.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted vibrotactile signal.\n    * `reference: np.array` Reference vibrotactile signal.\n    * `eta: float` Slope of the mapping function between error and score.\n    * `threshold: float` Offset of the mapping function.\n\n    Returns\n    -------\n    * `float` The SPQI score.\n    \"\"\"\n    metric = SPQI(eta, threshold)\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"metrics/stsim/","title":"Spectral Temporal SIMilarity (ST-SIM)","text":"<p>Research Paper: https://ieeexplore.ieee.org/document/8943164</p>"},{"location":"metrics/stsim/#reference","title":"Reference","text":"<p>Spectral Temporal SIMilarity.</p>"},{"location":"metrics/stsim/#vibromaf.metrics.stsim.STSIM","title":"<code>STSIM</code>  <code>dataclass</code>","text":"<p>Spectral Temporal SIMilarity.</p> Source code in <code>vibromaf/metrics/stsim.py</code> <pre><code>@dataclass(frozen=True)\nclass STSIM:\n    \"\"\"Spectral Temporal SIMilarity.\"\"\"\n\n    eta: float\n    perceptual_spectrum_builder = PerceptualSpectrumBuilder()\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        distorted = preprocess_input_signal(distorted, reference)\n        if np.array_equal(distorted, reference):\n            return 1\n\n        ref_spectral_support = compute_spectral_support(\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(reference)\n        )\n        dist_spectral_support = compute_spectral_support(\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(distorted)\n        )\n        spectral_sim = STSIM.compute_sim(ref_spectral_support, dist_spectral_support)\n\n        ref_normalized_blocks = (\n            self.perceptual_spectrum_builder.block_builder.divide_and_normalize(\n                reference\n            )\n        )\n        dist_normalized_blocks = (\n            self.perceptual_spectrum_builder.block_builder.divide_and_normalize(\n                distorted\n            )\n        )\n        temporal_sim = STSIM.compute_sim(ref_normalized_blocks, dist_normalized_blocks)\n\n        return pow(temporal_sim, self.eta) * pow(spectral_sim, 1 - self.eta)\n\n    @staticmethod\n    def compute_sim(reference: np.array, distorted: np.array) -&gt; float:\n        return float(\n            np.mean(\n                np.sum(reference * distorted, axis=1)\n                / (np.sum(np.power(reference, 2), axis=1) + np.finfo(float).eps)\n            )\n        )\n\n    def __post_init__(self):\n        if not 0.0 &lt; self.eta &lt; 1.0:\n            raise ValueError(\"Eta must be between 0 and 1.\")\n</code></pre>"},{"location":"metrics/stsim/#vibromaf.metrics.stsim.st_sim","title":"<code>st_sim(distorted, reference, eta=2 / 3)</code>","text":"<p>Wrapper function to calculate the ST-SIM score.</p>"},{"location":"metrics/stsim/#vibromaf.metrics.stsim.st_sim--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted vibrotactile signal.</li> <li><code>reference: np.array</code> Reference vibrotactile signal.</li> <li><code>eta: float</code> Importance of temporal component compared to spectral component. Should be between 0 and 1.</li> </ul>"},{"location":"metrics/stsim/#vibromaf.metrics.stsim.st_sim--returns","title":"Returns","text":"<ul> <li><code>float</code> The ST-SIM score.</li> </ul> Source code in <code>vibromaf/metrics/stsim.py</code> <pre><code>def st_sim(distorted: np.array, reference: np.array, eta: float = 2 / 3) -&gt; float:\n    \"\"\"Wrapper function to calculate the ST-SIM score.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted vibrotactile signal.\n    * `reference: np.array` Reference vibrotactile signal.\n    * `eta: float` Importance of temporal component compared to spectral component. Should be between 0 and 1.\n\n    Returns\n    -------\n    * `float` The ST-SIM score.\n    \"\"\"\n    metric = STSIM(eta)\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"metrics/vibromaf/","title":"Vibrotactile Multi-Method Assessment Fusion (VibroMAF)","text":""},{"location":"metrics/vibromaf/#reference","title":"Reference","text":"<p>Vibrotactile Multi-Method Assessment Fusion.</p>"},{"location":"metrics/vibromaf/#vibromaf.metrics.vibromaf.VibroMAF","title":"<code>VibroMAF</code>","text":"<p>Vibrotactile Multi-Method Assessment Fusion.</p> Source code in <code>vibromaf/metrics/vibromaf.py</code> <pre><code>class VibroMAF:\n    \"\"\"Vibrotactile Multi-Method Assessment Fusion.\"\"\"\n\n    def __init__(self, model_path: Path, spqi: SPQI, st_sim: STSIM) -&gt; None:\n        self.__model = model.load_model(model_path)\n        self.__spqi = spqi\n        self.__st_sim = st_sim\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        signal_to_noise_ratio = nsnr(distorted, reference)\n        st_sim = self.__st_sim.calculate(distorted, reference)\n        spqi = self.__spqi.calculate(distorted, reference)\n        return float(self.__model.predict([[signal_to_noise_ratio, st_sim, spqi]]))\n</code></pre>"},{"location":"metrics/vibromaf/#vibromaf.metrics.vibromaf.vibro_maf","title":"<code>vibro_maf(distorted, reference, model_path)</code>","text":"<p>Wrapper function to calculate the SPQI score.</p> Source code in <code>vibromaf/metrics/vibromaf.py</code> <pre><code>def vibro_maf(distorted: np.array, reference: np.array, model_path: Path) -&gt; float:\n    \"\"\"Wrapper function to calculate the SPQI score.\"\"\"\n    metric = VibroMAF(model_path, SPQI(0.3, -2.0), STSIM(2 / 3))\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>vibromaf<ul> <li>config</li> <li>metrics<ul> <li>snr</li> <li>spqi</li> <li>stsim</li> <li>vibromaf</li> </ul> </li> <li>signal<ul> <li>perception</li> <li>spectrum</li> <li>transform</li> </ul> </li> <li>util<ul> <li>common</li> <li>matlab</li> <li>model</li> </ul> </li> </ul> </li> </ul>"},{"location":"reference/vibromaf/","title":"vibromaf","text":""},{"location":"reference/vibromaf/config/","title":"config","text":"<p>Vibromaf config.</p>"},{"location":"reference/vibromaf/metrics/","title":"metrics","text":""},{"location":"reference/vibromaf/metrics/snr/","title":"snr","text":"<p>Signal to Noise Ratio.</p>"},{"location":"reference/vibromaf/metrics/snr/#vibromaf.metrics.snr.nsnr","title":"<code>nsnr(distorted, reference, normalization_db=75)</code>","text":"<p>Calculate the normalized signal-to-noise ratio restricted to range of 0 to 1.</p> Source code in <code>vibromaf/metrics/snr.py</code> <pre><code>def nsnr(\n    distorted: np.array, reference: np.array, normalization_db: float = 75\n) -&gt; float:\n    \"\"\"Calculate the normalized signal-to-noise ratio restricted to range of 0 to 1.\"\"\"\n    return max(0.0, min(1.0, snr(distorted, reference) / normalization_db))\n</code></pre>"},{"location":"reference/vibromaf/metrics/snr/#vibromaf.metrics.snr.snr","title":"<code>snr(distorted, reference)</code>","text":"<p>Calculate the signal-to-noise ratio.</p>"},{"location":"reference/vibromaf/metrics/snr/#vibromaf.metrics.snr.snr--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted signal.</li> <li><code>reference: np.array</code> Reference signal.</li> </ul>"},{"location":"reference/vibromaf/metrics/snr/#vibromaf.metrics.snr.snr--returns","title":"Returns","text":"<ul> <li><code>float</code> The SNR.</li> </ul> Source code in <code>vibromaf/metrics/snr.py</code> <pre><code>def snr(distorted: np.array, reference: np.array) -&gt; float:\n    \"\"\"Calculate the signal-to-noise ratio.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted signal.\n    * `reference: np.array` Reference signal.\n\n    Returns\n    -------\n    * `float` The SNR.\n    \"\"\"\n    distorted = preprocess_input_signal(distorted, reference)\n    return pow2db(signal_energy(reference) / signal_energy(distorted - reference))\n</code></pre>"},{"location":"reference/vibromaf/metrics/spqi/","title":"spqi","text":"<p>Spectral Perceptual Quality Index.</p>"},{"location":"reference/vibromaf/metrics/spqi/#vibromaf.metrics.spqi.SPQI","title":"<code>SPQI</code>  <code>dataclass</code>","text":"<p>Spectral Perceptual Quality Index.</p> Source code in <code>vibromaf/metrics/spqi.py</code> <pre><code>@dataclass(frozen=True)\nclass SPQI:\n    \"\"\"Spectral Perceptual Quality Index.\"\"\"\n\n    eta: float\n    threshold: float\n    perceptual_spectrum_builder = PerceptualSpectrumBuilder()\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        distorted = preprocess_input_signal(distorted, reference)\n        if np.array_equal(distorted, reference):\n            return 1\n\n        ref_perceptual_spectrum = (\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(reference)\n        )\n        dist_perceptual_spectrum = (\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(distorted)\n        )\n\n        norm_perceptual_difference = compute_normalized_spectral_difference(\n            ref_perceptual_spectrum, dist_perceptual_spectrum\n        )\n\n        block_spqi_scores = self.__compute_block_spqi(norm_perceptual_difference)\n\n        return float(np.mean(block_spqi_scores))\n\n    def __compute_block_spqi(\n        self, normalized_perceptual_difference: np.array\n    ) -&gt; np.array:\n        return (\n            1 - np.tanh(self.eta * normalized_perceptual_difference - self.threshold)\n        ) / 2\n</code></pre>"},{"location":"reference/vibromaf/metrics/spqi/#vibromaf.metrics.spqi.spqi","title":"<code>spqi(distorted, reference, eta=0.3, threshold=-2.0)</code>","text":"<p>Wrapper function to calculate the SPQI score.</p>"},{"location":"reference/vibromaf/metrics/spqi/#vibromaf.metrics.spqi.spqi--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted vibrotactile signal.</li> <li><code>reference: np.array</code> Reference vibrotactile signal.</li> <li><code>eta: float</code> Slope of the mapping function between error and score.</li> <li><code>threshold: float</code> Offset of the mapping function.</li> </ul>"},{"location":"reference/vibromaf/metrics/spqi/#vibromaf.metrics.spqi.spqi--returns","title":"Returns","text":"<ul> <li><code>float</code> The SPQI score.</li> </ul> Source code in <code>vibromaf/metrics/spqi.py</code> <pre><code>def spqi(\n    distorted: np.array, reference: np.array, eta: float = 0.3, threshold: float = -2.0\n) -&gt; float:\n    \"\"\"Wrapper function to calculate the SPQI score.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted vibrotactile signal.\n    * `reference: np.array` Reference vibrotactile signal.\n    * `eta: float` Slope of the mapping function between error and score.\n    * `threshold: float` Offset of the mapping function.\n\n    Returns\n    -------\n    * `float` The SPQI score.\n    \"\"\"\n    metric = SPQI(eta, threshold)\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"reference/vibromaf/metrics/stsim/","title":"stsim","text":"<p>Spectral Temporal SIMilarity.</p>"},{"location":"reference/vibromaf/metrics/stsim/#vibromaf.metrics.stsim.STSIM","title":"<code>STSIM</code>  <code>dataclass</code>","text":"<p>Spectral Temporal SIMilarity.</p> Source code in <code>vibromaf/metrics/stsim.py</code> <pre><code>@dataclass(frozen=True)\nclass STSIM:\n    \"\"\"Spectral Temporal SIMilarity.\"\"\"\n\n    eta: float\n    perceptual_spectrum_builder = PerceptualSpectrumBuilder()\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        distorted = preprocess_input_signal(distorted, reference)\n        if np.array_equal(distorted, reference):\n            return 1\n\n        ref_spectral_support = compute_spectral_support(\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(reference)\n        )\n        dist_spectral_support = compute_spectral_support(\n            self.perceptual_spectrum_builder.compute_perceptual_spectrum(distorted)\n        )\n        spectral_sim = STSIM.compute_sim(ref_spectral_support, dist_spectral_support)\n\n        ref_normalized_blocks = (\n            self.perceptual_spectrum_builder.block_builder.divide_and_normalize(\n                reference\n            )\n        )\n        dist_normalized_blocks = (\n            self.perceptual_spectrum_builder.block_builder.divide_and_normalize(\n                distorted\n            )\n        )\n        temporal_sim = STSIM.compute_sim(ref_normalized_blocks, dist_normalized_blocks)\n\n        return pow(temporal_sim, self.eta) * pow(spectral_sim, 1 - self.eta)\n\n    @staticmethod\n    def compute_sim(reference: np.array, distorted: np.array) -&gt; float:\n        return float(\n            np.mean(\n                np.sum(reference * distorted, axis=1)\n                / (np.sum(np.power(reference, 2), axis=1) + np.finfo(float).eps)\n            )\n        )\n\n    def __post_init__(self):\n        if not 0.0 &lt; self.eta &lt; 1.0:\n            raise ValueError(\"Eta must be between 0 and 1.\")\n</code></pre>"},{"location":"reference/vibromaf/metrics/stsim/#vibromaf.metrics.stsim.st_sim","title":"<code>st_sim(distorted, reference, eta=2 / 3)</code>","text":"<p>Wrapper function to calculate the ST-SIM score.</p>"},{"location":"reference/vibromaf/metrics/stsim/#vibromaf.metrics.stsim.st_sim--parameters","title":"Parameters","text":"<ul> <li><code>distorted: np.array</code> Distorted vibrotactile signal.</li> <li><code>reference: np.array</code> Reference vibrotactile signal.</li> <li><code>eta: float</code> Importance of temporal component compared to spectral component. Should be between 0 and 1.</li> </ul>"},{"location":"reference/vibromaf/metrics/stsim/#vibromaf.metrics.stsim.st_sim--returns","title":"Returns","text":"<ul> <li><code>float</code> The ST-SIM score.</li> </ul> Source code in <code>vibromaf/metrics/stsim.py</code> <pre><code>def st_sim(distorted: np.array, reference: np.array, eta: float = 2 / 3) -&gt; float:\n    \"\"\"Wrapper function to calculate the ST-SIM score.\n\n    Parameters\n    ------\n    * `distorted: np.array` Distorted vibrotactile signal.\n    * `reference: np.array` Reference vibrotactile signal.\n    * `eta: float` Importance of temporal component compared to spectral component. Should be between 0 and 1.\n\n    Returns\n    -------\n    * `float` The ST-SIM score.\n    \"\"\"\n    metric = STSIM(eta)\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"reference/vibromaf/metrics/vibromaf/","title":"vibromaf","text":"<p>Vibrotactile Multi-Method Assessment Fusion.</p>"},{"location":"reference/vibromaf/metrics/vibromaf/#vibromaf.metrics.vibromaf.VibroMAF","title":"<code>VibroMAF</code>","text":"<p>Vibrotactile Multi-Method Assessment Fusion.</p> Source code in <code>vibromaf/metrics/vibromaf.py</code> <pre><code>class VibroMAF:\n    \"\"\"Vibrotactile Multi-Method Assessment Fusion.\"\"\"\n\n    def __init__(self, model_path: Path, spqi: SPQI, st_sim: STSIM) -&gt; None:\n        self.__model = model.load_model(model_path)\n        self.__spqi = spqi\n        self.__st_sim = st_sim\n\n    def calculate(self, distorted: np.array, reference: np.array) -&gt; float:\n        signal_to_noise_ratio = nsnr(distorted, reference)\n        st_sim = self.__st_sim.calculate(distorted, reference)\n        spqi = self.__spqi.calculate(distorted, reference)\n        return float(self.__model.predict([[signal_to_noise_ratio, st_sim, spqi]]))\n</code></pre>"},{"location":"reference/vibromaf/metrics/vibromaf/#vibromaf.metrics.vibromaf.vibro_maf","title":"<code>vibro_maf(distorted, reference, model_path)</code>","text":"<p>Wrapper function to calculate the SPQI score.</p> Source code in <code>vibromaf/metrics/vibromaf.py</code> <pre><code>def vibro_maf(distorted: np.array, reference: np.array, model_path: Path) -&gt; float:\n    \"\"\"Wrapper function to calculate the SPQI score.\"\"\"\n    metric = VibroMAF(model_path, SPQI(0.3, -2.0), STSIM(2 / 3))\n    return metric.calculate(distorted, reference)\n</code></pre>"},{"location":"reference/vibromaf/signal/","title":"signal","text":""},{"location":"reference/vibromaf/signal/perception/","title":"perception","text":"<p>Module human vibrotactile perception.</p>"},{"location":"reference/vibromaf/signal/perception/#vibromaf.signal.perception.PerceptualThreshold","title":"<code>PerceptualThreshold</code>  <code>dataclass</code>","text":"<p>Human perceptual threshold.</p> Source code in <code>vibromaf/signal/perception.py</code> <pre><code>@dataclass(frozen=True)\nclass PerceptualThreshold:\n    \"\"\"Human perceptual threshold.\"\"\"\n\n    sampling_frequency: int\n    x_scaler: float = 62\n    y_scaler: float = 1 / 550\n    x_offset: float = 1 - 250 * y_scaler\n    y_offset: float = 77\n\n    def calculate(self, block_length: int) -&gt; np.array:\n        frequency_grid = np.linspace(0, self.sampling_frequency, 2 * block_length)\n        frequency_grid = frequency_grid[0:block_length]\n\n        perceptual_threshold = (\n            abs(\n                self.x_scaler\n                / pow((math.log10(self.x_offset)), 2)\n                * np.power(\n                    (np.log10(self.y_scaler * frequency_grid + self.x_offset)), 2\n                )\n            )\n            - self.y_offset\n        )\n        limit = np.argmax(perceptual_threshold &gt; 0)\n        perceptual_threshold[limit:] = perceptual_threshold[limit]\n        return perceptual_threshold\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/","title":"spectrum","text":"<p>Spectrum module.</p>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.compute_normalized_spectral_difference","title":"<code>compute_normalized_spectral_difference(reference_spectrum, distorted_spectrum)</code>","text":"<p>Compute the normalized difference of two spectra.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def compute_normalized_spectral_difference(\n    reference_spectrum: np.array, distorted_spectrum: np.array\n) -&gt; np.array:\n    \"\"\"Compute the normalized difference of two spectra.\"\"\"\n    difference = np.sum(\n        np.abs(db2pow(reference_spectrum) - db2pow(distorted_spectrum)), axis=1\n    )\n    return pow2db(\n        difference\n        / (np.sum(np.abs(db2pow(reference_spectrum)), axis=1) + np.finfo(float).eps)\n    )\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.compute_spectral_support","title":"<code>compute_spectral_support(spectrum, scale=12)</code>","text":"<p>Compute the spectral support of perceptual spectrum using a normal distribution cdf.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def compute_spectral_support(spectrum: np.array, scale: float = 12) -&gt; np.array:\n    \"\"\"Compute the spectral support of perceptual spectrum using a normal distribution\n    cdf.\"\"\"\n    return np.apply_along_axis(norm.cdf, 1, spectrum, scale=scale)\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.db2pow","title":"<code>db2pow(decibel)</code>","text":"<p>Convert decibel to power https://de.mathworks.com/help/signal/ref/db2pow.html.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def db2pow(decibel: np.array) -&gt; np.array:\n    \"\"\"Convert decibel to power https://de.mathworks.com/help/signal/ref/db2pow.html.\"\"\"\n    return np.power(10.0, decibel / 10.0)\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.mag2db","title":"<code>mag2db(power)</code>","text":"<p>Convert magnitude to decibels https://de.mathworks.com/help/signal/ref/mag2db.html.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def mag2db(power: np.array) -&gt; np.array:\n    \"\"\"Convert magnitude to decibels\n    https://de.mathworks.com/help/signal/ref/mag2db.html.\"\"\"\n    return 2 * pow2db(power)\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.pow2db","title":"<code>pow2db(power)</code>","text":"<p>Convert power to decibels https://de.mathworks.com/help/signal/ref/pow2db.html.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def pow2db(power: np.array) -&gt; np.array:\n    \"\"\"Convert power to decibels\n    https://de.mathworks.com/help/signal/ref/pow2db.html.\"\"\"\n    return 10.0 * np.log10(power)\n</code></pre>"},{"location":"reference/vibromaf/signal/spectrum/#vibromaf.signal.spectrum.signal_energy","title":"<code>signal_energy(signal)</code>","text":"<p>Calculate the signal energy.</p> Source code in <code>vibromaf/signal/spectrum.py</code> <pre><code>def signal_energy(signal: np.array) -&gt; np.array:\n    \"\"\"Calculate the signal energy.\"\"\"\n    return np.sum(np.square(signal, dtype=np.float64))\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/","title":"transform","text":"<p>Transform module.</p>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.BlockBuilder","title":"<code>BlockBuilder</code>  <code>dataclass</code>","text":"<p>Split signal into blocks.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>@dataclass(frozen=True)\nclass BlockBuilder:\n    \"\"\"Split signal into blocks.\"\"\"\n\n    block_length: int\n    truncation_strategy: Callable[[np.array], np.array] = cut_off_strategy\n\n    def divide(self, signal: np.array) -&gt; np.array:\n        if signal.size &lt; self.block_length:\n            raise ValueError(\n                \"Signal is too short! The signal must be at least as long as the block length.\"\n            )\n        signal = self.truncation_strategy(signal, self.block_length)\n        return np.reshape(signal, (-1, self.block_length))\n\n    def divide_and_normalize(self, signal: np.array) -&gt; np.array:\n        blocks = self.divide(signal)\n        means = np.apply_along_axis(np.mean, 1, blocks).reshape((blocks.shape[0], 1))\n        stds = np.apply_along_axis(np.std, 1, blocks).reshape((blocks.shape[0], 1))\n        return (blocks - means) / (stds + np.finfo(float).eps)\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.PerceptualSpectrumBuilder","title":"<code>PerceptualSpectrumBuilder</code>  <code>dataclass</code>","text":"<p>Calculate perceptual spectrum.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>@dataclass(frozen=True)\nclass PerceptualSpectrumBuilder:\n    \"\"\"Calculate perceptual spectrum.\"\"\"\n\n    block_builder: BlockBuilder = field(default_factory=lambda: BlockBuilder(512))\n    perceptual_threshold: PerceptualThreshold = field(\n        default_factory=lambda: PerceptualThreshold(8000)\n    )\n    block_transform_strategy: Callable[[np.array], np.array] = compute_block_dct\n\n    def compute_perceptual_spectrum(self, signal: np.array) -&gt; np.array:\n        blocks = self.block_builder.divide(signal)\n        spectrum = np.apply_along_axis(self.block_transform_strategy, 1, blocks)\n        return spectrum - self.perceptual_threshold.calculate(\n            self.block_builder.block_length\n        )\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.compute_block_dct","title":"<code>compute_block_dct(block)</code>","text":"<p>Compute block transform using DCT.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>def compute_block_dct(block: np.array) -&gt; np.array:\n    \"\"\"Compute block transform using DCT.\"\"\"\n    return mag2db(abs(dct(block, norm=\"ortho\")))\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.compute_block_dft","title":"<code>compute_block_dft(block)</code>","text":"<p>Compute DFT spectrum using FFT.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>def compute_block_dft(block: np.array) -&gt; np.array:\n    \"\"\"Compute DFT spectrum using FFT.\"\"\"\n    block_length = np.size(block)\n    extended_block = np.zeros(\n        2 * block_length,\n    )\n    extended_block[0:block_length] = block\n    return mag2db(abs(1 / math.sqrt(block_length) * np.fft.fft(extended_block)))[\n        0:block_length\n    ]\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.cut_off_strategy","title":"<code>cut_off_strategy(signal, block_length)</code>","text":"<p>Prepare signal for block building by cutting off.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>def cut_off_strategy(signal: np.array, block_length: int) -&gt; np.array:\n    \"\"\"Prepare signal for block building by cutting off.\"\"\"\n    num_blocks = int(signal.size / block_length)\n    return signal[: num_blocks * block_length]\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.preprocess_input_signal","title":"<code>preprocess_input_signal(distorted, reference)</code>","text":"<p>Verify input signal lengths and prepare distorted signal for the metrics.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>def preprocess_input_signal(distorted: np.array, reference: np.array) -&gt; np.array:\n    \"\"\"Verify input signal lengths and prepare distorted signal for the metrics.\"\"\"\n    if distorted.size &gt; reference.size:\n        warnings.warn(\n            f\"Truncating distorted signal {distorted.shape} since longer than reference signal {reference.shape}.\",\n            RuntimeWarning,\n            stacklevel=2,\n        )\n        return np.resize(distorted, reference.shape)\n    if distorted.size &lt; reference.size:\n        raise ValueError(\n            f\"Distorted signal {distorted.shape} must not be shorter than reference signal {reference.shape}!\",\n        )\n    return distorted\n</code></pre>"},{"location":"reference/vibromaf/signal/transform/#vibromaf.signal.transform.zero_padding_strategy","title":"<code>zero_padding_strategy(signal, block_length)</code>","text":"<p>Prepare signal for block building by padding with zeros.</p> Source code in <code>vibromaf/signal/transform.py</code> <pre><code>def zero_padding_strategy(signal: np.array, block_length: int) -&gt; np.array:\n    \"\"\"Prepare signal for block building by padding with zeros.\"\"\"\n    num_padding = block_length * math.ceil(signal.size / block_length) - signal.size\n    return np.pad(signal, (0, num_padding), \"constant\")\n</code></pre>"},{"location":"reference/vibromaf/util/","title":"util","text":""},{"location":"reference/vibromaf/util/common/","title":"common","text":"<p>Common utilities.</p>"},{"location":"reference/vibromaf/util/common/#vibromaf.util.common.print_metric","title":"<code>print_metric(text, score)</code>","text":"<p>Print metric score in predefined format.</p> Source code in <code>vibromaf/util/common.py</code> <pre><code>def print_metric(text: str, score: float):\n    \"\"\"Print metric score in predefined format.\"\"\"\n    print(f\"{text:40s} {score:.3f}\")\n</code></pre>"},{"location":"reference/vibromaf/util/common/#vibromaf.util.common.print_mse_and_pc","title":"<code>print_mse_and_pc(name, y_true, y_pred)</code>","text":"<p>Print MSE and Pearson Correlation for signal.</p> Source code in <code>vibromaf/util/common.py</code> <pre><code>def print_mse_and_pc(name: str, y_true, y_pred):\n    \"\"\"Print MSE and Pearson Correlation for signal.\"\"\"\n    mse_test = mean_squared_error(y_true, y_pred)\n    cor_test = np.corrcoef(y_true, y_pred)[0, 1]\n\n    print_metric(f\"{name} MSE\", mse_test)\n    print_metric(f\"{name} PC\", cor_test)\n</code></pre>"},{"location":"reference/vibromaf/util/matlab/","title":"matlab","text":"<p>Utility functions for MATLAB files.</p>"},{"location":"reference/vibromaf/util/matlab/#vibromaf.util.matlab.MatSignalLoader","title":"<code>MatSignalLoader</code>","text":"<p>Helper class to load test signals from mat files.</p> Source code in <code>vibromaf/util/matlab.py</code> <pre><code>class MatSignalLoader:\n    \"\"\"Helper class to load test signals from mat files.\"\"\"\n\n    def __init__(self, metric: str, codec: str = \"VCPWQ\") -&gt; None:\n        self.__reference = load_signal_from_mat(\n            config.DATA_PATH / \"Signals.mat\", \"Signals\"\n        )\n        self.__distorted = load_signal_from_mat(\n            config.DATA_PATH / f\"recsig_{codec}.mat\", f\"recsig_{codec}\"\n        )\n        self.__metric_scores = load_signal_from_mat(\n            config.DATA_PATH / f\"{metric}_{codec}.mat\", f\"{metric}_{codec}\"\n        )\n\n    def signal_ids(self):\n        return range(self.__reference.shape[1])\n\n    def compression_levels(self):\n        return range(self.__distorted.shape[0])\n\n    def load_reference_signal(self, signal_id: int):\n        return self.__reference[:, signal_id]\n\n    def load_distorted_signal(self, signal_id: int, compression_level: int):\n        return self.__distorted[compression_level, signal_id].reshape(\n            -1,\n        )\n\n    def load_quality_score(self, signal_id: int, compression_level: int):\n        return self.__metric_scores[compression_level, signal_id]\n</code></pre>"},{"location":"reference/vibromaf/util/matlab/#vibromaf.util.matlab.load_data_for_metric","title":"<code>load_data_for_metric(metric, test_indices)</code>","text":"<p>Load and concatenate the training and test data.</p> Source code in <code>vibromaf/util/matlab.py</code> <pre><code>def load_data_for_metric(\n    metric: str, test_indices: list[int]\n) -&gt; tuple[np.array, np.array]:\n    \"\"\"Load and concatenate the training and test data.\"\"\"\n    vcpwq = load_signal_from_mat(\n        config.DATA_PATH / f\"{metric}_VCPWQ.mat\", f\"{metric}_VCPWQ\"\n    )\n    pvcslp = load_signal_from_mat(\n        config.DATA_PATH / f\"{metric}_PVCSLP.mat\", f\"{metric}_PVCSLP\"\n    )\n    vpcds = load_signal_from_mat(\n        config.DATA_PATH / f\"{metric}_VPCDS.mat\", f\"{metric}_VPCDS\"\n    )\n\n    train_indices = [\n        element for element in range(vcpwq.shape[1]) if element not in test_indices\n    ]\n\n    return np.concatenate(\n        [\n            vcpwq[:, train_indices].flatten(),\n            pvcslp[:, train_indices].flatten(),\n            vpcds[:, train_indices].flatten(),\n        ]\n    ), np.concatenate(\n        [\n            vcpwq[:, test_indices].flatten(),\n            pvcslp[:, test_indices].flatten(),\n            vpcds[:, test_indices].flatten(),\n        ]\n    )\n</code></pre>"},{"location":"reference/vibromaf/util/matlab/#vibromaf.util.matlab.load_signal_from_mat","title":"<code>load_signal_from_mat(mat_file, signal_name)</code>","text":"<p>Load .mat file and parse signal from it.</p> Source code in <code>vibromaf/util/matlab.py</code> <pre><code>def load_signal_from_mat(mat_file: Path, signal_name: str) -&gt; np.array:\n    \"\"\"Load .mat file and parse signal from it.\"\"\"\n    mat = io.loadmat(str(mat_file))\n    try:\n        return mat[signal_name]\n    except KeyError as exc:\n        raise KeyError(f\"Available keys: {mat.keys()}\") from exc\n</code></pre>"},{"location":"reference/vibromaf/util/matlab/#vibromaf.util.matlab.reshape_per_compression_rate","title":"<code>reshape_per_compression_rate(data, number_of_compression_levels=17)</code>","text":"<p>Reshape the data into same compression level per row.</p> Source code in <code>vibromaf/util/matlab.py</code> <pre><code>def reshape_per_compression_rate(\n    data: np.array, number_of_compression_levels: int = 17\n) -&gt; np.array:\n    \"\"\"Reshape the data into same compression level per row.\"\"\"\n    number_of_columns = int(data.size / number_of_compression_levels)\n    return data.reshape((number_of_compression_levels, number_of_columns))\n</code></pre>"},{"location":"reference/vibromaf/util/matlab/#vibromaf.util.matlab.split_per_codec","title":"<code>split_per_codec(data, number_of_codecs=3)</code>","text":"<p>Split the data into equal pieces:</p> <p>As we concatenate them per codec this is a split per codec</p> Source code in <code>vibromaf/util/matlab.py</code> <pre><code>def split_per_codec(data: np.array, number_of_codecs: int = 3) -&gt; np.array:\n    \"\"\"Split the data into equal pieces:\n\n    As we concatenate them per codec this is a split per codec\n    \"\"\"\n    return np.split(data, number_of_codecs)\n</code></pre>"},{"location":"reference/vibromaf/util/model/","title":"model","text":"<p>Utility functions for the vibromaf model.</p>"},{"location":"reference/vibromaf/util/model/#vibromaf.util.model.load_model","title":"<code>load_model(model_path)</code>","text":"<p>Load the model from a file.</p> Source code in <code>vibromaf/util/model.py</code> <pre><code>def load_model(model_path: Path):\n    \"\"\"Load the model from a file.\"\"\"\n    return pickle.loads(model_path.read_bytes())\n</code></pre>"},{"location":"reference/vibromaf/util/model/#vibromaf.util.model.make_vibromaf_pipeline","title":"<code>make_vibromaf_pipeline()</code>","text":"<p>Create the vibromaf SVM regressor pipeline.</p> Source code in <code>vibromaf/util/model.py</code> <pre><code>def make_vibromaf_pipeline() -&gt; Pipeline:\n    \"\"\"Create the vibromaf SVM regressor pipeline.\"\"\"\n    return make_pipeline(StandardScaler(), SVR(kernel=\"rbf\", C=3000, epsilon=0.1))\n</code></pre>"},{"location":"reference/vibromaf/util/model/#vibromaf.util.model.save_model","title":"<code>save_model(model, model_path)</code>","text":"<p>Save the model into a file.</p> Source code in <code>vibromaf/util/model.py</code> <pre><code>def save_model(model, model_path: Path) -&gt; None:\n    \"\"\"Save the model into a file.\"\"\"\n    model_path.write_bytes(pickle.dumps(model))\n</code></pre>"}]}